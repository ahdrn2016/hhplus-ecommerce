# 동시성 제어 방식에 대한 분석 보고서

---

## 개요
e-commerce 시나리오에서 동시성 문제가 발생할 수 있는 주요 상황을 3가지로 정의하였습니다.
- 유저의 포인트 충전/결제
- 주문 시 상품 재고 차감
- 선착순 쿠폰 발급

이를 해결하기 위해 동시성 제어 방식에 대해 분석하고, 해당 비즈니스 로직에서 적합하다고 판단한 동시성 제어 방식을 구현하였습니다.

---

## 낙관적 락 (Optimistic Lock)
- 동시성이 높지 않거나 충돌이 드물게 발생하는 경우에 적합하다.
- 데이터를 읽을 때 버전 정보를 함께 가져오고, 업데이트 시점에 버전 정보를 비교하여 충돌 여부를 확인한다. (```@Version``` 필수!)
- 충돌이 발생하면 ```@Retryable```을 사용해 다시 읽고 업데이트 하는 방식으로 구현할 수 있다.
- 충돌이 잦으면 재시도로 인해 오히려 성능이 저하될 수 있는 단점이 있는데, 특정 유저의 포인트 충전/결제 서비스에서 충돌 빈도가 낮다고 판단하였습니다.
#### 충돌 가능성이 낮다고 판단되는 ```유저의 포인트 충전/결제```로직에 낙관적 락을 적용하였습니다.
#### @Retryable로 재시도 횟수와 대기 시간을 설정하여 재시도 로직이 지나치게 많아지지 않도록 설정하였습니다.


---

## 비관적 락 (Pessimistic Lock)
- 충돌 가능성이 높거나 데이터 **일관성, 정합성**이 매우 중요한 경우에 적합하다.
- 데이터를 읽을 때 즉시 데이터베이스에 락을 걸어 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 차단해 충돌 가능성을 사전에 방지한다. (```SELECT ... FOR UPDATE```)
- 락이 걸린 동안 다른 트랜잭션이 대기해야 하므로 병목 현상이 발생할 수 있다.
- 여러 유저가 동시에 동일한 상품을 주문할 수 있기에 충돌 가능성을 사전에 차단하여 안정적으로 재고를 관리해야한다고 판단하였습니다.
#### 충돌 가능성이 높다고 판단되는 ```주문 시 상품 재고 차감```로직에 비관적 락을 적용하였습니다.
#### 재고가 1개인 상품에 대해 여러 유저가 주문을 시도하더라도, 첫 번째 트랜잭션이 완료된 후에 두 번째 트랜잭션이 실행되므로 재고 부족 상황을 방지할 수 있습니다.
#### 비관적 락이 병목 현상을 유발할 수 있으나, 재고 차감 로직은 단일 트랜잭션으로 처리되므로 이러한 영향은 최소화됩니다.

---

## 분산 락 (with Redis Pub/Sub)
- 분산 시스템에서 서로 다른 서버 인스턴스에 대한 일관된 락을 제공한다.
- Key-value 기반의 원자성을 이용한 Redis를 통해 DB 부하를 최소화한다.
- Pub/Sub 기능을 활용해 락 획득 실패 시, "구독"하고 차례가 될 때까지 이벤트를 기다리는 방식으로 효율적인 Lock 관리가 가능하다.
- 락과 트랜잭션은 데이터의 무결성을 보장하기 위해 아래 순서에 맞게 수행되어야 한다.
  - 락 획득 > 트랜잭션 시작 > 비즈니스 로직 수행 > 트랜잭션 종료 > 락 해제
#### 한 번에 대량의 트래픽이 몰릴 경우 DB에 락을 걸면 과부하로 장애가 발생할 수 있다고 생각하여 ```선착순 쿠폰 발급```로직에 분산 락을 적용하였습니다.
#### 분산 락과 Redis Pub/Sub을 활용하여 대량 트래픽 상황에서도 일관된 락 관리로 데이터 무결성을 보장하고, DB 부하를 최소화하며 선착순 쿠폰 발급을 안정적으로 처리할 수 있습니다.

---

## 결론
본 보고서에서는 e-commerce 시스템에서 발생할 수 있는 동시성 문제를 해결하기 위해 낙관적 락, 비관적 락, 분산 락을 각각의 비즈니스 시나리오에 맞게 적용하였습니다.

이를 통해 데이터 일관성과 시스템 안정성을 보장하며, 동시에 트래픽 부하를 효율적으로 관리할 수 있음을 확인하였습니다. 

각 동시성 제어 방식을 상황에 맞게 설계하여 안정성을 제공하도록 구현하였습니다.