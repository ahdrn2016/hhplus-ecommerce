# MSA 형태로 서비스 분리에 따른 트랜잭션 처리 한계 보고서

---
## 목차
1. [개요](#1-개요)
2. [기존 시스템의 트랜잭션 관리](#2-기존-시스템의-트랜잭션-관리)
3. [MSA로 분리 시 트랜잭션 처리 한계](#3-msa로-분리-시-트랜잭션-처리-한계)
4. [트랜잭션 처리 한계 해결방안](#4-트랜잭션-처리-한계-해결방안)
5. [SAGA Orchestration + Outbox 패턴 설계](#5-saga-orchestration--outbox-패턴-설계)
6. [결론](#6-결론)

---
## 1. 개요
기존 모놀리식 구조에서 서비스 규모의 확장성을 고려하여 마이크로서비스 아키텍처(MSA)의 형태로 분리해야한다는 가정 하에 작성하였습니다.<br>
`주문 기능`을 MSA 형태로 분리 시 트랜잭션 처리의 한계와 해결방안에 대해 알아보았습니다.

---
## 2. 기존 시스템의 트랜잭션 관리
```java
@Transactional
public OrderResult.Payment order(OrderCriteria.Order criteria) {
    상품정보조회();
    주문생성();
    쿠폰사용();
    결제생성();
    포인트사용();
    재고차감();
    주문완료(); 
}
```
위와 같이 기존 모놀리식 구조에서는 하나의 트랜잭션 내에서 모든 작업을 처리하기 때문에 데이터의 일관성을 보장할 수 있었습니다.
하지만, 트랜잭션이 너무 많은 작업을 포함하면 성능 저하와 데드락 발생 가능성이 높아질 수 있습니다.

기존 시스템의 구조에서 MSA 형태로 분리한다면 `상품`, `쿠폰`, `포인트`, `주문/결제` 서비스로 나누어 분리해볼 수 있을 것 같습니다.

---
## 3. MSA로 분리 시 트랜잭션 처리 한계
- 서비스 별로 분리되어 하나의 비즈니스 로직이 여러 개별 DB를 변경해야하는 경우 트랜잭션이 분산된다.
  각각 트랜잭션으로 나뉘어져 DBMS가 지원하는 트랜잭션을 통한 데이터 일관성 유지가 어려워진다.
- 분산 트랜잭션은 네트워크 지연, 장애 발생 시 다른 서비스에서 이미 수행된 작업을 롤백하기 어려워진다.

---
## 4. 트랜잭션 처리 한계 해결방안
### 4.1 2PC (2-Phase Commit)
1. **준비 단계(Prepare Phase)**: 모든 관련 서비스가 트랜잭션을 준비하고 커밋 가능 여부를 코디네이터 전달
2. **커밋 단계(Commit Phase)**: 모든 서비스가 준비 완료되면 코디네이터가 커밋 명령, 실패 시 롤백 명령을 보냄

→ 높은 일관성을 보장하지만, 성능이 떨어지고 장애 발생 시 복잡한 복구 절차가 필요하다.<br>
→ 코디네이터 장애 시 트랜잭션이 교착 상태에 빠질 가능성이 크다.

### 4.2 SAGA 패턴
#### Choreography 기반 SAGA
- 각 서비스가 이벤트를 발행하고, 다른 서비스가 이벤트를 감지하여 트랜잭션을 실행
- 중앙 컨트롤러 없이 이벤트 기반으로 비즈니스 로직을 처리

→ 서비스 간 결합도가 낮으며 확장성이 뛰어나다.<br>
→ 이벤트 흐름 관리가 어렵고, 장애 발생 시 이벤트 추적이 어렵다.

#### Orchestration 기반 SAGA
- 중앙 오케스트레이터가 전체 트랜잭션을 관리하며, 각 서비스에 순차적으로 명령 전달
- 각 서비스는 오케스트레이터의 요청을 받아 트랜잭션 수행 후 응답을 반환

→ 트랜잭션 흐름을 중앙에서 관리하고, 오류 발생 시 보상 트랜잭션을 쉽게 수행할 수 있다.<br>
→ 중앙 집중 방식으로 단일 장애점(SPOF) 발생 가능성이 높다.

### 4.3 Outbox 패턴
1. 서비스가 데이터를 커밋하면서, 같은 트랜잭션으로 Outbox 테이블에 이벤트 기록
2. 이벤트 프로세서가 주기적으로 Outbox 테이블에서 이벤트 조회
3. 조회된 이벤트를 메시지 브로커(Kafka, SNS 등)로 전송
4. 이벤트가 정상적으로 전송되면 Outbox 테이블에서 해당 이벤트 삭제

→ 트랜잭션 일관성을 유지하며, 네트워크 장애 발생 시에도 이벤트가 안전하게 저장된다.<br>
→ 이벤트가 중복 발생할 가능성이 있어 로직을 멱등하게 설계해야 한다.

---
## 5. SAGA Orchestration + Outbox 패턴 설계
**트랜잭션 정상 처리 흐름**
1. SAGA 중앙 오케스트레이터가 순차적으로 서비스 호출
2. 서비스는 트랜잭션에서 작업을 수행하며 데이터를 커밋하고 Outbox 테이블에 이벤트 기록
3. 이벤트 프로세서가 Outbox에서 테이블을 읽어 메시지 브로커 전송
4. SAGA 중앙 오케스트레이터가 마지막 서비스에서 완료 이벤트를 감지하면 전체 트랜잭션 완료

**장애 발생 시 보상 트랜잭션 처리**
1. SAGA 중앙 오케스트레이터가 이전 서비스의 취소(보상 트랜잭션) 기능 호출
2. 해당 서비스는 보상 트랜잭션 수행 후 Outbox 테이블에 취소 이벤트 저장
3. 이벤트 프로세서가 취소 이벤트를 감지하여 메시지 브로커로 전송
4. 다른 서비스에서 취소 이벤트를 구독하고, 보상 트랜잭션 수행

---
## 6. 결론
MSA 환경에서는 각 서비스가 독립적인 트랜잭션을 가지므로, 분산 트랜잭션 환경에서도 데이터 정합성을 유지하는 것이 중요합니다.<br>
`SAGA Orchestration + Outbox 패턴`을 조합하면 SAGA 중앙 오케스트레이터가 트랜잭션 흐름을 중앙에서 관리하며, 장애 발생 시 보상 트랜잭션을 실행함으로써 데이터 일관성을 유지할 수 있습니다.<br>
다만, Outbox 패턴의 이벤트 중복 발생 문제와 보상 트랜잭션 실행 중 장애 발생 시 복구 문제를 해결하기 위해, 모든 트랜잭션 로직을 멱등하게 설계하는 것이 중요할 것 같습니다.
